---
globs: src/main/services/database.ts
description: 数据库操作规范
---

# 数据库操作规范

## 数据库服务架构

所有数据库操作统一通过 `databaseService` 进行，禁止直接使用 `better-sqlite3`。

```typescript
// ✅ 正确
import { databaseService } from './services/database'
const book = databaseService.getBookById(id)

// ❌ 错误
import Database from 'better-sqlite3'
const db = new Database(/* ... */)
```

## 方法命名规范

### 查询操作
- `get*ById`：根据 ID 查询单条记录
- `get*By*`：根据条件查询单条记录
- `getAll*`：查询所有记录
- `get*List`：查询列表（带条件）
- `search*`：模糊搜索

```typescript
getBookById(id: number): Book | null
getBookByTitle(title: string): Book | null
getAllBooks(): Book[]
getBooksByStatus(status: ReadingStatus): Book[]
searchBooks(keyword: string): Book[]
```

### 修改操作
- `create*`：创建新记录
- `update*`：更新记录
- `delete*`：删除记录（物理删除）
- `remove*`：逻辑删除（如需要）

```typescript
createBook(input: BookInput): Book
updateBook(id: number, input: Partial<BookInput>): Book | null
deleteBook(id: number): boolean
```

## SQL 查询规范

### 参数化查询

**必须使用参数化查询防止 SQL 注入**：

```typescript
// ✅ 正确
const stmt = db.prepare('SELECT * FROM books WHERE id = ?')
const book = stmt.get(id)

// ❌ 错误
const book = db.prepare(`SELECT * FROM books WHERE id = ${id}`).get()
```

### 事务处理

批量操作使用事务：

```typescript
const transaction = db.transaction((books: BookInput[]) => {
  const stmt = db.prepare('INSERT INTO books (...) VALUES (...)')
  for (const book of books) {
    stmt.run(book.title, book.author, /* ... */)
  }
})
transaction(books)
```

### 错误处理

```typescript
try {
  const book = databaseService.getBookById(id)
  if (!book) {
    throw new Error('书籍不存在')
  }
  return book
} catch (error: any) {
  console.error('查询书籍失败:', error)
  throw new Error(`查询失败: ${error.message}`)
}
```

## 返回类型规范

### 单条查询
- 存在返回对象，不存在返回 `null`
- 类型：`Book | null`

```typescript
getBookById(id: number): Book | null {
  const stmt = db.prepare('SELECT * FROM books WHERE id = ?')
  const row = stmt.get(id) as BookRow | undefined
  return row ? this.mapRowToBook(row) : null
}
```

### 列表查询
- 始终返回数组，即使为空
- 类型：`Book[]`

```typescript
getAllBooks(): Book[] {
  const stmt = db.prepare('SELECT * FROM books ORDER BY created_at DESC')
  const rows = stmt.all() as BookRow[]
  return rows.map(row => this.mapRowToBook(row))
}
```

### 创建/更新操作
- 创建：返回创建的对象
- 更新：成功返回更新后的对象，失败返回 `null`

```typescript
createBook(input: BookInput): Book {
  const stmt = db.prepare(/* ... */)
  const result = stmt.run(/* ... */)
  return this.getBookById(result.lastInsertRowid)!
}

updateBook(id: number, input: Partial<BookInput>): Book | null {
  // 更新逻辑
  return this.getBookById(id)
}
```

## 数据映射

### Row 到 Domain 对象

数据库行（snake_case）转换为领域对象（camelCase）：

```typescript
private mapRowToBook(row: BookRow): Book {
  return {
    id: row.id,
    title: row.title,
    author: row.author,
    readingStatus: row.reading_status,
    createdAt: new Date(row.created_at),
    updatedAt: new Date(row.updated_at)
  }
}
```

### Domain 对象到 Row

领域对象转换为数据库行：

```typescript
private mapBookToRow(book: BookInput): BookRowInput {
  return {
    title: book.title,
    author: book.author,
    reading_status: book.readingStatus || 'unread',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString()
  }
}
```

## 性能优化

### 索引使用
- 为常用查询字段创建索引
- 在 `schema.sql` 中定义索引

```sql
CREATE INDEX idx_books_reading_status ON books(reading_status);
CREATE INDEX idx_books_created_at ON books(created_at);
```

### 批量操作
- 使用事务处理批量操作
- 使用 `prepare` 预编译语句

```typescript
const insertStmt = db.prepare('INSERT INTO books (...) VALUES (...)')
const insertMany = db.transaction((books: BookInput[]) => {
  for (const book of books) {
    insertStmt.run(/* ... */)
  }
})
```

## 数据库初始化

- 在 `main/index.ts` 的 `app.whenReady()` 中初始化
- 读取并执行 `database/schema.sql`
- 使用 WAL 模式提高性能

```typescript
app.whenReady().then(() => {
  try {
    databaseService.initialize()
  } catch (error) {
    console.error('数据库初始化失败:', error)
  }
})
```

## 连接管理

- 应用启动时创建连接
- 应用退出时关闭连接
- 使用单例模式管理连接

```typescript
app.on('before-quit', () => {
  databaseService.close()
})
```
