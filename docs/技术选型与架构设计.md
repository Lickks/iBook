# 技术选型与架构设计

## 一、技术栈对比与推荐

### 1.1 候选方案对比

| 维度 | Electron + Vue | C# + WPF | Python + PyQt |
|------|----------------|----------|---------------|
| **开发效率** |  |  |  |
| **性能表现** |  |  |  |
| **UI美观度** |  |  |  |
| **跨平台能力** |  |  |  |
| **资源占用** |  |  |  |
| **生态丰富度** |  |  |  |
| **学习曲线** |  |  |  |
| **打包体积** |  (150MB+) |  (30MB+) |  (80MB+) |

### 1.2 推荐方案：Electron + Vue 3

**推荐理由：**

1. **开发效率高：** 使用Vue 3前端框架，组件化开发，代码复用性强
2. **UI现代化：** 可以使用Element Plus、Ant Design等成熟的UI组件库，界面美观
3. **生态丰富：** npm生态庞大，各种文档解析、网络请求、数据可视化库应有尽有
4. **未来可扩展：** 一套代码可以扩展到macOS、Linux，甚至Web版
5. **适合你的背景：** 作为软件工程专业学生，前端技术栈的学习价值更高，就业面更广

**适用场景：**
- 追求快速开发和现代化UI
- 希望未来可能跨平台
- 不过分追求性能和体积（对于桌面应用，这不是核心问题）

---

## 二、技术架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    Electron Main Process                 │
│  ┌─────────────┐  ┌──────────────┐  ┌────────────────┐ │
│  │ Window Mgr  │  │  IPC Handler │  │  File System   │ │
│  └─────────────┘  └──────────────┘  └────────────────┘ │
│  ┌─────────────┐  ┌──────────────┐  ┌────────────────┐ │
│  │  Database   │  │ Spider Service│  │  Update Mgr    │ │
│  └─────────────┘  └──────────────┘  └────────────────┘ │
└─────────────────────────────────────────────────────────┘
                             ↕ IPC
┌─────────────────────────────────────────────────────────┐
│                 Electron Renderer Process                │
│                      (Vue 3 App)                         │
│  ┌─────────────────────────────────────────────────────┐│
│  │                     Views                            ││
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐            ││
│  │  │ Home    │  │ Detail  │  │ Stats   │            ││
│  │  └─────────┘  └─────────┘  └─────────┘            ││
│  └─────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────┐│
│  │                   Components                         ││
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐         ││
│  │  │ BookCard │  │ BookForm │  │ FileUpload│         ││
│  │  └──────────┘  └──────────┘  └──────────┘         ││
│  └─────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────┐│
│  │                  State Management (Pinia)            ││
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐         ││
│  │  │ BookStore│  │ UIStore  │  │ StatStore│         ││
│  │  └──────────┘  └──────────┘  └──────────┘         ││
│  └─────────────────────────────────────────────────────┘│
│  ┌─────────────────────────────────────────────────────┐│
│  │                  API Layer                           ││
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐         ││
│  │  │ BookAPI  │  │ DocAPI   │  │ SearchAPI│         ││
│  │  └──────────┘  └──────────┘  └──────────┘         ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘
                             ↕
┌─────────────────────────────────────────────────────────┐
│                    External Services                     │
│  ┌──────────────┐          ┌────────────────────────┐  │
│  │ SQLite DB    │          │  youshu.me API         │  │
│  │ (Local)      │          │  (HTTP)                │  │
│  └──────────────┘          └────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 2.2 技术栈清单

#### 核心框架
- **Electron**: v28+ （桌面应用容器）
- **Vue 3**: v3.4+ （前端框架）
- **TypeScript**: v5+ （类型安全）

#### UI组件库
- **Element Plus**: v2.5+ （UI组件库）
- **Tailwind CSS**: v3+ （样式框架，可选）

#### 状态管理
- **Pinia**: v2+ （Vue 3官方推荐状态管理）

#### 路由
- **Vue Router**: v4+ （页面路由）

#### 数据库
- **better-sqlite3**: v9+ （同步SQLite驱动，性能好）
  - 或 **sqlite3**: 异步版本

#### HTTP请求
- **Axios**: v1+ （HTTP客户端）
- **Cheerio**: v1+ （网页解析，Node.js版jQuery）
- **Puppeteer** (可选): 如果需要处理动态渲染的页面

#### 文档解析
- **epub.js**: EPUB格式解析
- **pdf-parse**: PDF解析
- **mammoth**: DOCX解析
- **jschardet**: 字符编码检测（处理TXT乱码）

#### 数据可视化
- **ECharts**: v5+ （图表库）

#### 工具库
- **dayjs**: 日期时间处理
- **lodash-es**: 工具函数库
- **uuid**: 生成唯一ID

#### 开发工具
- **Vite**: v5+ （构建工具）
- **ESLint**: 代码规范
- **Prettier**: 代码格式化
- **electron-builder**: 打包工具

---

## 三、目录结构设计

```
book-store/
├── electron/                      # Electron主进程代码
│   ├── main.ts                   # 主进程入口
│   ├── preload.ts                # 预加载脚本
│   ├── ipc/                      # IPC通信处理
│   │   ├── bookHandler.ts
│   │   ├── documentHandler.ts
│   │   └── searchHandler.ts
│   ├── services/                 # 主进程服务
│   │   ├── database.ts           # 数据库服务
│   │   ├── spider.ts             # 爬虫服务
│   │   ├── fileManager.ts        # 文件管理
│   │   └── wordCounter.ts        # 字数统计
│   └── utils/                    # 工具函数
│       ├── logger.ts
│       └── config.ts
│
├── src/                          # Vue渲染进程代码
│   ├── main.ts                   # Vue入口
│   ├── App.vue                   # 根组件
│   ├── router/                   # 路由配置
│   │   └── index.ts
│   ├── stores/                   # Pinia状态管理
│   │   ├── book.ts               # 书籍状态
│   │   ├── ui.ts                 # UI状态（主题、布局等）
│   │   └── stats.ts              # 统计数据状态
│   ├── views/                    # 页面组件
│   │   ├── Home.vue              # 首页（书籍列表）
│   │   ├── BookDetail.vue        # 书籍详情
│   │   ├── AddBook.vue           # 添加书籍
│   │   ├── Statistics.vue        # 统计分析
│   │   └── Settings.vue          # 设置页面
│   ├── components/               # 通用组件
│   │   ├── BookCard.vue          # 书籍卡片
│   │   ├── BookGrid.vue          # 书籍网格
│   │   ├── BookList.vue          # 书籍列表
│   │   ├── BookForm.vue          # 书籍表单
│   │   ├── SearchBar.vue         # 搜索栏
│   │   ├── FileUpload.vue        # 文件上传
│   │   ├── RatingStars.vue       # 星级评分
│   │   └── ProgressBar.vue       # 进度条
│   ├── api/                      # API接口层
│   │   ├── book.ts               # 书籍API
│   │   ├── document.ts           # 文档API
│   │   ├── search.ts             # 搜索API
│   │   └── stats.ts              # 统计API
│   ├── types/                    # TypeScript类型定义
│   │   ├── book.ts
│   │   ├── document.ts
│   │   └── api.ts
│   ├── utils/                    # 工具函数
│   │   ├── format.ts             # 格式化函数
│   │   └── validator.ts          # 验证函数
│   ├── assets/                   # 静态资源
│   │   ├── images/
│   │   ├── icons/
│   │   └── styles/
│   │       └── global.css
│   └── constants/                # 常量定义
│       └── index.ts
│
├── database/                     # 数据库相关
│   ├── schema.sql                # 数据库结构
│   ├── migrations/               # 数据库迁移脚本
│   └── seeds/                    # 初始数据（可选）
│
├── public/                       # 公共资源
│   ├── icon.png                  # 应用图标
│   └── default-cover.png         # 默认封面
│
├── docs/                         # 文档
│   ├── 需求分析文档.md
│   ├── 技术选型与架构设计.md
│   └── API文档.md
│
├── tests/                        # 测试代码
│   ├── unit/                     # 单元测试
│   └── e2e/                      # 端到端测试
│
├── .gitignore
├── .eslintrc.js
├── .prettierrc
├── package.json
├── tsconfig.json
├── vite.config.ts
├── electron-builder.json         # 打包配置
└── README.md
```

---

## 四、数据流设计

### 4.1 主进程与渲染进程通信（IPC）

#### 书籍操作流程

```
Renderer (Vue)                Main Process
    │                              │
    │  ipcRenderer.invoke          │
    │  ('book:create', data)       │
    ├─────────────────────────────>│
    │                              │ 1. 验证数据
    │                              │ 2. 插入数据库
    │                              │ 3. 返回结果
    │         Result               │
    │<─────────────────────────────┤
    │                              │
    │  Update Pinia Store          │
    │                              │
```

#### IPC通道设计

**书籍管理：**
- `book:create` - 创建书籍
- `book:update` - 更新书籍
- `book:delete` - 删除书籍
- `book:getById` - 获取单个书籍
- `book:getAll` - 获取所有书籍
- `book:search` - 搜索书籍

**文档管理：**
- `document:upload` - 上传文档
- `document:delete` - 删除文档
- `document:open` - 打开文档
- `document:countWords` - 统计字数

**搜索服务：**
- `search:youshu` - 从youshu.me搜索
- `search:cache` - 获取缓存的搜索结果

**系统操作：**
- `system:backup` - 备份数据
- `system:restore` - 恢复数据
- `system:export` - 导出数据

### 4.2 前端数据流（Pinia）

```typescript
// stores/book.ts
export const useBookStore = defineStore('book', {
  state: () => ({
    books: [] as Book[],
    currentBook: null as Book | null,
    loading: false,
    filters: {
      status: 'all',
      category: 'all',
      keyword: ''
    }
  }),
  
  getters: {
    filteredBooks: (state) => {
      return state.books.filter(book => {
        // 筛选逻辑
      })
    },
    
    totalWordCount: (state) => {
      return state.books.reduce((sum, book) => sum + book.wordCount, 0)
    }
  },
  
  actions: {
    async fetchBooks() {
      this.loading = true
      const books = await bookAPI.getAll()
      this.books = books
      this.loading = false
    },
    
    async createBook(bookData: BookInput) {
      const book = await bookAPI.create(bookData)
      this.books.push(book)
      return book
    },
    
    // ... 其他actions
  }
})
```

---

## 五、核心模块设计

### 5.1 数据库服务模块

```typescript
// electron/services/database.ts
import Database from 'better-sqlite3'
import path from 'path'
import { app } from 'electron'

class DatabaseService {
  private db: Database.Database
  
  constructor() {
    const dbPath = path.join(app.getPath('userData'), 'ibook.db')
    this.db = new Database(dbPath)
    this.init()
  }
  
  private init() {
    // 读取schema.sql并执行
    // 创建表结构
  }
  
  // 书籍操作
  createBook(book: BookInput): Book {
    const stmt = this.db.prepare(`
      INSERT INTO books (title, author, word_count_display, ...)
      VALUES (?, ?, ?, ...)
    `)
    const result = stmt.run(book.title, book.author, ...)
    return { id: result.lastInsertRowid, ...book }
  }
  
  getBookById(id: number): Book | null {
    const stmt = this.db.prepare('SELECT * FROM books WHERE id = ?')
    return stmt.get(id) as Book | null
  }
  
  getAllBooks(): Book[] {
    const stmt = this.db.prepare('SELECT * FROM books ORDER BY updated_at DESC')
    return stmt.all() as Book[]
  }
  
  updateBook(id: number, book: Partial<Book>): boolean {
    // 动态构建UPDATE语句
  }
  
  deleteBook(id: number): boolean {
    const stmt = this.db.prepare('DELETE FROM books WHERE id = ?')
    const result = stmt.run(id)
    return result.changes > 0
  }
  
  searchBooks(keyword: string): Book[] {
    const stmt = this.db.prepare(`
      SELECT * FROM books 
      WHERE title LIKE ? OR author LIKE ? OR description LIKE ?
    `)
    const pattern = `%${keyword}%`
    return stmt.all(pattern, pattern, pattern) as Book[]
  }
}

export const db = new DatabaseService()
```

### 5.2 爬虫服务模块

```typescript
// electron/services/spider.ts
import axios from 'axios'
import * as cheerio from 'cheerio'

interface SearchResult {
  title: string
  author: string
  cover: string
  platform: string
  wordCount: number
  description: string
  sourceUrl: string
}

class SpiderService {
  private baseUrl = 'https://www.youshu.me'
  
  async searchBook(keyword: string): Promise<SearchResult[]> {
    try {
      // 1. 发送搜索请求
      const response = await axios.get(`${this.baseUrl}/search`, {
        params: { q: keyword },
        timeout: 10000,
        headers: {
          'User-Agent': 'Mozilla/5.0 ...'
        }
      })
      
      // 2. 解析HTML
      const $ = cheerio.load(response.data)
      const results: SearchResult[] = []
      
      // 3. 提取数据（根据实际网页结构调整）
      $('.book-item').each((i, elem) => {
        results.push({
          title: $(elem).find('.title').text().trim(),
          author: $(elem).find('.author').text().trim(),
          cover: $(elem).find('img').attr('src') || '',
          platform: $(elem).find('.platform').text().trim(),
          wordCount: this.parseWordCount($(elem).find('.word-count').text()),
          description: $(elem).find('.desc').text().trim(),
          sourceUrl: $(elem).find('a').attr('href') || ''
        })
      })
      
      return results
    } catch (error) {
      console.error('搜索失败:', error)
      throw new Error('搜索服务暂时不可用，请稍后重试或手动添加')
    }
  }
  
  private parseWordCount(text: string): number {
    // 解析字数，如 "100万字" -> 1000000
    const match = text.match(/(\d+\.?\d*)(万)?/)
    if (!match) return 0
    const num = parseFloat(match[1])
    return match[2] === '万' ? num * 10000 : num
  }
  
  async downloadCover(url: string, savePath: string): Promise<void> {
    // 下载封面图片到本地
    const response = await axios.get(url, { responseType: 'arraybuffer' })
    await fs.promises.writeFile(savePath, response.data)
  }
}

export const spider = new SpiderService()
```

### 5.3 字数统计模块

```typescript
// electron/services/wordCounter.ts
import fs from 'fs'
import EPub from 'epub'
import pdf from 'pdf-parse'
import mammoth from 'mammoth'
import jschardet from 'jschardet'
import iconv from 'iconv-lite'

class WordCounterService {
  async countWords(filePath: string): Promise<number> {
    const ext = path.extname(filePath).toLowerCase()
    
    switch (ext) {
      case '.txt':
        return this.countTxt(filePath)
      case '.epub':
        return this.countEpub(filePath)
      case '.pdf':
        return this.countPdf(filePath)
      case '.docx':
        return this.countDocx(filePath)
      default:
        throw new Error(`不支持的文件格式: ${ext}`)
    }
  }
  
  private async countTxt(filePath: string): Promise<number> {
    // 1. 检测编码
    const buffer = await fs.promises.readFile(filePath)
    const detected = jschardet.detect(buffer)
    const encoding = detected.encoding || 'utf-8'
    
    // 2. 读取文本
    const text = iconv.decode(buffer, encoding)
    
    // 3. 统计字数（排除空白字符）
    return this.countChinese(text)
  }
  
  private async countEpub(filePath: string): Promise<number> {
    return new Promise((resolve, reject) => {
      const epub = new EPub(filePath)
      epub.on('end', async () => {
        let totalWords = 0
        const chapters = epub.flow
        
        for (const chapter of chapters) {
          const text = await this.getChapterText(epub, chapter.id)
          totalWords += this.countChinese(text)
        }
        
        resolve(totalWords)
      })
      epub.parse()
    })
  }
  
  private async countPdf(filePath: string): Promise<number> {
    const buffer = await fs.promises.readFile(filePath)
    const data = await pdf(buffer)
    return this.countChinese(data.text)
  }
  
  private async countDocx(filePath: string): Promise<number> {
    const result = await mammoth.extractRawText({ path: filePath })
    return this.countChinese(result.value)
  }
  
  private countChinese(text: string): number {
    // 统计中文字符数（不含标点和空格）
    // 根据需求可以调整：只统计中文，还是包含英文单词
    
    // 方案1：只统计中文字符
    const chineseChars = text.match(/[\u4e00-\u9fa5]/g)
    return chineseChars ? chineseChars.length : 0
    
    // 方案2：中文字符 + 英文单词数
    // const chinese = text.match(/[\u4e00-\u9fa5]/g) || []
    // const english = text.match(/[a-zA-Z]+/g) || []
    // return chinese.length + english.length
  }
}

export const wordCounter = new WordCounterService()
```

### 5.4 文件管理模块

```typescript
// electron/services/fileManager.ts
import fs from 'fs'
import path from 'path'
import { app } from 'electron'
import { v4 as uuidv4 } from 'uuid'

class FileManagerService {
  private baseDir: string
  
  constructor() {
    this.baseDir = path.join(app.getPath('userData'), 'documents')
    this.ensureDir(this.baseDir)
  }
  
  private ensureDir(dir: string) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true })
    }
  }
  
  async saveDocument(sourcePath: string, bookId: number): Promise<string> {
    // 1. 生成新文件名（避免冲突）
    const ext = path.extname(sourcePath)
    const newFileName = `${bookId}_${uuidv4()}${ext}`
    const destPath = path.join(this.baseDir, newFileName)
    
    // 2. 复制文件
    await fs.promises.copyFile(sourcePath, destPath)
    
    return destPath
  }
  
  async deleteDocument(filePath: string): Promise<void> {
    if (fs.existsSync(filePath)) {
      await fs.promises.unlink(filePath)
    }
  }
  
  async openDocument(filePath: string): Promise<void> {
    const { shell } = require('electron')
    await shell.openPath(filePath)
  }
  
  getFileSize(filePath: string): number {
    const stats = fs.statSync(filePath)
    return stats.size
  }
  
  getFileType(filePath: string): string {
    return path.extname(filePath).toLowerCase().replace('.', '')
  }
}

export const fileManager = new FileManagerService()
```

---

## 六、性能优化策略

### 6.1 数据库优化

```sql
-- 创建索引（已实现）
CREATE INDEX idx_books_title ON books(title);
CREATE INDEX idx_books_author ON books(author);
CREATE INDEX idx_books_status ON books(reading_status);
CREATE INDEX idx_books_created_at ON books(created_at);

-- 复合索引（已实现）
CREATE INDEX idx_books_category_platform ON books(category, platform);
CREATE INDEX idx_books_title_author ON books(title, author);
CREATE INDEX idx_book_tags_composite ON book_tags(book_id, tag_id);

-- 全文搜索索引（如果SQLite版本支持FTS5）
CREATE VIRTUAL TABLE books_fts USING fts5(title, author, description);
```

**已实现的优化：**
- [已完成] 批量查询标签，避免N+1查询问题
- [已完成] 复合索引优化筛选和搜索查询
- [已完成] 分页查询支持，减少单次查询数据量
- [已完成] 查询结果缓存（LRU策略，5分钟有效期）

### 6.2 前端优化

1. [已完成] **虚拟滚动：** 自定义实现，超过50本书时启用
2. [已完成] **图片懒加载：** 使用浏览器原生loading="lazy"
3. [已完成] **组件懒加载：** 路由级别的组件懒加载（已实现）
4. [已完成] **防抖节流：** 搜索输入和筛选操作使用防抖（300ms）
5. [已完成] **分页加载：** 数据库查询支持分页（已实现）
6. [已完成] **减少重渲染：** 使用shallowRef、v-memo和计算属性缓存

### 6.3 主进程优化

1. **Worker线程：** 字数统计等耗时操作使用Worker线程
2. [已完成] **缓存机制：** 查询结果缓存（已实现），封面缓存
3. [已完成] **批量操作：** 批量导入时使用事务（已实现）

---

## 七、安全性设计

### 7.1 SQL注入防护
- 使用参数化查询，避免字符串拼接SQL

### 7.2 XSS防护
- Vue默认会转义HTML，但用户输入的描述、笔记需注意

### 7.3 文件上传安全
- 限制文件类型
- 限制文件大小
- 文件路径验证（防止路径穿越攻击）

### 7.4 数据加密（可选）
- 敏感数据可以使用SQLCipher进行加密

---

## 八、为什么这样设计

### 8.1 为什么选择Electron？
- **跨平台能力：** 未来可能需要支持Mac或Linux
- **前端技术栈：** 利用你的前端知识，开发效率高
- **生态丰富：** 各种文档解析库在Node.js环境中都有成熟方案

### 8.2 为什么使用Pinia而不是Vuex？
- Pinia是Vue 3官方推荐的状态管理库
- 更好的TypeScript支持
- API更简洁，没有mutations
- 模块化更自然

### 8.3 为什么选择better-sqlite3？
- 同步API，代码更简洁
- 性能优于异步版本的sqlite3
- 更适合桌面应用场景

### 8.4 为什么分离主进程和渲染进程？
- **安全性：** 渲染进程（Vue）不能直接访问Node.js API，通过IPC通信更安全
- **性能：** 主进程处理耗时操作（数据库、文件），不阻塞UI渲染
- **架构清晰：** 职责分离，代码更易维护

---

## 九、开发注意事项

### 9.1 Electron Context Isolation
- 必须启用上下文隔离（contextIsolation: true）
- 通过preload脚本暴露安全的API给渲染进程

### 9.2 TypeScript类型定义
- 主进程和渲染进程共享类型定义（放在src/types/）
- IPC通道名称建议定义为常量，避免拼写错误

### 9.3 错误处理
- 网络请求需要超时和重试机制
- 文件操作需要异常捕获
- 用户友好的错误提示

### 9.4 日志记录
- 使用electron-log记录日志到文件
- 区分开发环境和生产环境的日志级别

---

## 十、实际实现总结 [已完成]

### 10.1 已完成的功能模块

**核心功能（MVP）：** [已完成]
1. [已完成] 项目框架已搭建（electron-vite 模板）
2. [已完成] 数据库设计已完成（schema.sql）
3. [已完成] 数据库服务已实现（完整的 CRUD 操作）
4. [已完成] 主进程 IPC 处理器已实现（book、document、search、stats）
5. [已完成] 前端页面已实现（Home、BookDetail、AddBook、Statistics）
6. [已完成] 核心组件已实现（BookCard、BookForm、SearchBar 等）

**扩展功能：** [已完成]
1. [已完成] 网络检索功能（youshu.me 爬虫）
2. [已完成] 文档管理功能（上传、删除、打开、字数统计）
3. [已完成] 多格式字数统计（TXT、EPUB、PDF、DOCX）
4. [已完成] 阅读状态管理（5种状态）
5. [已完成] 统计分析功能（6个指标 + 5个图表）
6. [已完成] 批量操作（选择、删除、状态更新）

### 10.2 技术栈实际使用情况

**已使用的核心库：**
- [已完成] Electron v28+ - 主进程和窗口管理
- [已完成] Vue 3.5.21 - 前端框架
- [已完成] TypeScript 5.9.2 - 类型安全
- [已完成] Element Plus 2.11.8 - UI 组件库
- [已完成] Pinia 3.0.4 - 状态管理
- [已完成] Vue Router 4.6.3 - 路由管理
- [已完成] better-sqlite3 12.4.6 - 数据库
- [已完成] axios 1.13.2 - HTTP 请求
- [已完成] cheerio 1.1.2 - HTML 解析
- [已完成] ECharts 6.0.0 - 图表库

**已使用的文档解析库：**
- [已完成] epub 1.3.0 - EPUB 解析
- [已完成] pdf-parse 2.4.5 - PDF 解析
- [已完成] mammoth 1.11.0 - DOCX 解析
- [已完成] jschardet 3.1.4 - 编码检测
- [已完成] iconv-lite 0.7.0 - 编码转换

### 10.3 架构实现情况

**主进程架构：** [已完成]
- [已完成] 数据库服务层（database.ts）
- [已完成] 业务服务层（spider、fileManager、wordCounter、cover）
- [已完成] IPC 处理层（bookHandler、documentHandler、searchHandler、statsHandler）
- [已完成] 统一错误处理和响应格式

**渲染进程架构：** [已完成]
- [已完成] 视图层（Views）- 5个主要页面
- [已完成] 组件层（Components）- 多个通用组件
- [已完成] 状态管理层（Stores）- Pinia 状态管理
- [已完成] API 层（API）- 统一的 IPC 调用封装
- [已完成] 类型定义层（Types）- 完整的 TypeScript 类型

**通信架构：** [已完成]
- [已完成] Preload 脚本暴露安全 API
- [已完成] IPC 双向通信
- [已完成] 类型安全的 API 调用

### 10.4 项目状态

**当前版本：** MVP + 核心扩展功能

**已完成阶段：**
- [已完成] 阶段一：项目初始化与环境搭建
- [已完成] 阶段二：数据库设计与服务实现
- [已完成] 阶段三：Electron 主进程实现
- [已完成] 阶段四：Vue 前端基础框架
- [已完成] 阶段五：核心页面实现（MVP）
- [已完成] 阶段六：检索与爬虫功能
- [已完成] 阶段七：文档管理功能
- [已完成] 阶段八：阅读进度管理（状态管理部分）
- [已完成] 阶段十：统计分析功能

**待实现阶段：**
- [待实现] 阶段十一：标签系统、高级筛选与排序
- [待实现] 阶段十二：数据备份与恢复
- [待实现] 阶段十三：UI 优化与主题
- [待实现] 阶段十四：性能优化

**已废弃功能：**
- [已废弃] 阶段九：评分与笔记（已废弃）
- [已废弃] 阅读进度跟踪（ProgressBar 组件）
- [已废弃] 数据导出功能（Excel/CSV 导出）

### 10.5 下一步建议

1. **完善标签系统** - 实现标签管理、为书籍打标签、按标签筛选
2. **优化筛选排序** - 实现多条件筛选、多种排序方式
3. **数据备份** - 实现自动备份和恢复功能
4. **UI 优化** - 完善主题系统、优化交互体验
5. **性能优化** - 大数据量时的查询优化、虚拟滚动等

---

## 十一、项目现状总结

项目已完成了核心功能的开发，可以正常使用。架构设计合理，代码组织清晰，具有良好的可扩展性。

**推荐继续开发顺序：**
1. [已完成] 标签系统（阶段十一）- 已完成
2. 数据备份（阶段十二）
3. [已完成] UI 优化（阶段十三）- 已完成
4. [已完成] 性能优化（阶段十四）- 已完成

